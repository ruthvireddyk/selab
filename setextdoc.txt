




NAGIOS : Nagios is an open‑source monitoring tool used to track the health, performance, and availability of IT systems, networks, and applications. It helps administrators detect problems early, send alerts, and ensure uptime across critical services.

Task:
1. Pull official Nagios image.docker pull jasonrivers/nagios:latest
2. Run container exposing ports.docker run --name nagiosdemo -p 8888:80 jasonrivers/nagios:latest
3. Access Nagios web interface to show Monitor CPU usage, memory, and service uptime. - open localhost : 8888 - user- nagiosadmin - pw-nagios

MINIKUBE: Minikube creates a VM on your local machine and deploys a simple Kubernetes cluster with one node. It's a lightweight implementation.Minikube is a version of Kubernetes.

oTask:
1. Start Minikube.: minikube start --driver=docker
2.minikube status
ominikube kubectl -- get pods -A[optional]
okubectl version --client

2. Create an Nginx deployment.minikube start
kubectl create deployment mynginx --image=nginx
[[if already created then 
kubectl set image deployment/myngnix nginx=nginx:latest]]
kubectl get deployments --[to verify]
Kubectl get pods 
Kubectl describe pods
3. Expose service on port 8090.
kubectl expose deployment mynginx --type=NodePort --port=80 --target-port=80
kubectl port-forward svc/mynginx 8081:80

4. Verify in browser and list all pods and services
Kubectl get pods 
kubectl get service myngnix
kubectl scale deployment mynginx --replicas=4[only if asked]





JENKINS PIPELINE SCRIPT-- NEW PIPELINE :
 triggers: build periodically: schedule : H/15 * * * *
-------------------------------------------------------------------------------------------------------------------------
pipeline {
    agent any
    tools{
        maven 'MAVEN-HOME'
    }
    stages {
        stage('git repo & clean') {
            steps {
                //bat "rmdir  /s /q mavenjava"
                bat "git clone provide your github link"
                bat "mvn clean -f mavenjava"
            }
        }
        stage('install') {
            steps {
                bat "mvn install -f mavenjava" #project name#
            }
        }
        stage('test') {
            steps {
                bat "mvn test -f mavenjava"
            }
        }
        stage('package') {
            steps {
                bat "mvn package -f mavenjava"
            }
        }
    }
}


==============================================================================================================================
pipeline {
    agent any
    tools {
        maven 'MAVEN_HOME'
    }
    stages {
        stage('git repo & clean') {
            steps {
                // only remove if present so the step doesn't fail when folder is absent
                bat 'if exist javaproject rmdir /s /q javaproject'
                bat 'git clone https://github.com/pkavya05/javaproject.git'
                bat 'mvn clean -f javaproject/pom.xml'
            }
        }
        stage('install') {
            steps {
                bat 'mvn install -f javaproject/pom.xml'
            }
        }
        stage('test') {
            steps {
                bat 'mvn test -f javaproject/pom.xml'
            }
        }
        stage('package') {
            steps {
                bat 'mvn package -f javaproject/pom.xml'
            }
        }
    }
}







Steps for MavenJava Automation:
I.
Maven Java Automation Steps:
 Step 1: Open Jenkins (localhost:8080)
    ├── Click on "New Item" (left side menu
Step 2: Create Freestyle Project (e.g., MavenJava_Build)
         ├── Enter project name (e.g., MavenJava_Build)
         ├── Click "OK"
└── Configure the project:
             ├── Description: "Java Build demo"
             ├── Source Code Management:
             └── Git repository URL: [GitMavenJava repo URL]
             ├── Branches to build: */Main   or  */master
   └── Build Steps:
                    ├── Add Build Step -> "Invoke top-level Maven targets"
                   └── Maven version: MAVEN_HOME
                  └── Goals: clean
                 ├── Add Build Step -> "Invoke top-level Maven targets"
                 └── Maven version: MAVEN_HOME
                 └── Goals: install
                 └── Post-build Actions:
                           ├── Add Post Build Action -> "Archive the artifacts"
                     └── Files to archive: **/*
                         ├── Add Post Build Action -> "Build other projects"
                     └── Projects to build: MavenJava_Test
                     └── Trigger: Only if build is stable
                         └── Apply and Save

    └── Step 3: Create Freestyle Project (e.g., MavenJava_Test)
         ├── Enter project name (e.g., MavenJava_Test)
         ├── Click "OK"
              └── Configure the project:
             ├── Description: "Test demo"
             ├── Build Environment:
             └── Check: "Delete the workspace before build starts"
            ├── Add Build Step -> "Copy artifacts from another project"
             └── Project name: MavenJava_Build
             └── Build: Stable build only  // tick at this
             └── Artifacts to copy: **/*
            ├── Add Build Step -> "Invoke top-level Maven targets"
             └── Maven version: MAVEN_HOME
             └── Goals: test
             └── Post-build Actions:
                ├── Add Post Build Action -> "Archive the artifacts"
                 └── Files to archive: **/*
                 └── Apply and Save

    └── Step 4: Create Pipeline View for Maven Java project
        ├── Click "+" beside "All" on the dashboard
        ├── Enter name: MavenJava_Pipeline
        ├── Select "Build pipeline view"         // tick here
         |--- create
        └── Pipeline Flow:
            ├── Layout: Based on upstream/downstream relationship
            ├── Initial job: MavenJava_Build
            └── Apply and Save OK

    └── Step 5: Run the Pipeline and Check Output
        ├── Click on the trigger to run the pipeline
        ├── click on the small black box to open the console to check if the build is success
            Note : 
1.
If build is success and the test project is also automatically triggered with name       
2.
                      “MavenJava_Test”
1.
The pipeline is successful if it is in green color as shown ->check the console of the test project
2.
3.
The test project is successful and all the artifacts are archived successfully
4.
II.Maven Web Automation Steps:

POM.XML FOR WEB DEPLOY
<?xml version="1.0" encoding="UTF-8"?>
<tomcat-users xmlns="http://tomcat.apache.org/xml"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd"
              version="1.0">

    <!-- Define roles -->
<role rolename="manager-gui"/>
<role rolename="manager-script"/>
<role rolename="admin-gui"/>
<role rolename="admin-script"/>
<user username="admin" password="1234" roles="manager-gui,manager-script,admin-gui,admin-script"/>


</tomcat-users>
III.
└── Step 1: Open Jenkins (localhost:8080)
    ├── Click on "New Item" (left side menu)
    
    └── Step 2: Create Freestyle Project (e.g., MavenWeb_Build)
        ├── Enter project name (e.g., MavenWeb_Build)
        ├── Click "OK"
        └── Configure the project:
            ├── Description: "Web Build demo"
            ├── Source Code Management:
             └── Git repository URL: [GitMavenWeb repo URL]
            ├── Branches to build: */Main or master
            └── Build Steps:
                ├── Add Build Step -> "Invoke top-level Maven targets"
                 └── Maven version: MAVEN_HOME
                 └── Goals: clean
                ├── Add Build Step -> "Invoke top-level Maven targets"
                 └── Maven version: MAVEN_HOME
                 └── Goals: install
                └── Post-build Actions:
                    ├── Add Post Build Action -> "Archive the artifacts"
                    └── Files to archive: **/*
                    ├── Add Post Build Action -> "Build other projects"
                     └── Projects to build: MavenWeb_Test
                     └── Trigger: Only if build is stable
                    └── Apply and Save

    └── Step 3: Create Freestyle Project (e.g., MavenWeb_Test)
        ├── Enter project name (e.g., MavenWeb_Test)
        ├── Click "OK"
        └── Configure the project:
            ├── Description: "Test demo"
            ├── Build Environment:
             └── Check: "Delete the workspace before build starts"
            ├── Add Build Step -> "Copy artifacts from another project"
             └── Project name: MavenWeb_Build
             └── Build: Stable build only
             └── Artifacts to copy: **/*
            ├── Add Build Step -> "Invoke top-level Maven targets"
            └── Maven version: MAVEN_HOME
             └── Goals: test
            └── Post-build Actions:
                ├── Add Post Build Action -> "Archive the artifacts"
                 └── Files to archive: **/*
                ├── Add Post Build Action -> "Build other projects"
                 └── Projects to build: MavenWeb_Deploy
                └── Apply and Save

    └── Step 4: Create Freestyle Project (e.g., MavenWeb_Deploy)
        ├── Enter project name (e.g., MavenWeb_Deploy)
        ├── Click "OK"
        └── Configure the project:
            ├── Description: "Web Code Deployment"
            ├── Build Environment:
             └── Check: "Delete the workspace before build starts"
            ├── Add Build Step -> "Copy artifacts from another project"
             └── Project name: MavenWeb_Test
             └── Build: Stable build only
                └── Artifacts to copy: **/*
            └── Post-build Actions:
                ├── Add Post Build Action -> "Deploy WAR/EAR to a container"
   └── WAR/EAR File: **/*.war
   └── Context path: Webpath
 └── Add container -> Tomcat 9.x remote
└── Credentials: Username: admin, Password: 1234
── Tomcat URL: https://localhost:8085/
                └── Apply and Save

    └── Step 5: Create Pipeline View for MavenWeb
        ├── Click "+" beside "All" on the dashboard
        ├── Enter name: MavenWeb_Pipeline
        ├── Select "Build pipeline view"
        └── Pipeline Flow:
            ├── Layout: Based on upstream/downstream relationship
            ├── Initial job: MavenWeb_Build
            └── Apply and Save

    └── Step 6: Run the Pipeline and Check Output
        ├── Click on the trigger “RUN” to run the pipeline
            Note: 
1.
After Click on Run -> click on the small black box to open the console to check if the build is success
Now we see all the build has  success if it appears in green color
2.
        ├── Open Tomcat homepage in another tab
        ├── Click on the "/webpath" option under the manager app
               Note:
 It ask for user credentials for login ,provide the credentials of tomcat.
It provide the page with out project name which is highlighted.
After clicking on our project we can see output.











































=======================================================================================================================

setting Up   Jenkins Email Notification Setup (Using Gmail with App Password)
Creation of app password
1. Gmail: Enable App Password (for 2-Step Verification)
i. Go to: https://myaccount.google.com
ii. Enable 2-Step Verification
Navigate to:
Security → 2-Step Verification
Turn it ON
Complete the OTP verification process (via phone/email)

iii. Generate App Password for Jenkins
Go to
Security → App passwords
Select:
App: Other (Custom name)
Name: Jenkins-Demo
Click Generate
Copy the 16-digit app password
Save it in a secure location (e.g., Notepad)
                 2.  Jenkins Plugin Installation
i. Open Jenkins Dashboard
ii. Navigate to:
Manage Jenkins → Manage Plugins
iii. Install Plugin:
Search for and install:
Email Extension Plugin

3. Configure Jenkins Global Email Settings
i. Go to:
Manage Jenkins → Configure System

A. E-mail Notification Section
Field	Value
SMTP Server	smtp.gmail.com
Use SMTP Auth	✅ Enabled
User Name	Your Gmail ID (e.g.,bhargavikumbham@gmail.com)
Password	Paste the 16-digit App Password
Use SSL	✅ Enabled
SMTP Port	465
Reply-To Address	Your Gmail ID (same as above)
➤ Test Configuration
Click: Test configuration by sending test e-mail
Provide a valid email address to receive a test mail
✅ Should receive email from Jenkins

B. Extended E-mail Notification Section
Field	Value
SMTP Server	smtp.gmail.com
SMTP Port	465
Use SSL	✅ Enabled
Credentials	Add Gmail ID and App Password as Jenkins credentials
Default Content Type	text/html or leave default
Default Recipients	Leave empty or provide default emails
Triggers	Select as per needs (e.g., Failure)

4.  Configure Email Notifications for a Jenkins Job
i. Go to:
Jenkins → Select a Job → Configure

ii. In the Post-build Actions section:
Click: Add post-build action → Editable Email Notification

A. Fill in the fields:
Field	Value
Project Recipient List	Add recipient email addresses (comma-separated)
Content Type	Default (text/plain) or text/html
Triggers	Select events (e.g., Failure, Success, etc.)
Attachments	(Optional) Add logs, reports, etc.

iii. Click Save

 Now your Jenkins job is set up to send email notifications based on the build status!







==================================================4
AWS 
Steps for Deploying  application into the cloud
I.
Create application and  Push into github
Create the virtual machine and connect to it.
Clone the application from github, Write the Dockerfile
Create the image

Run the image and access it public ip of virtual machine

   Create Maven-web-java project in eclipse & push into github

Create the virtual machine (EC2--instance) in aws and connect to 

Using Amazon EC2 eliminates your need to invest in hardware up front, so you can develop and deploy applications faster. 
Ex : Launch ubuntu instnace
Step 1: Login to AWS /canvas account
Step 2: Services --  EC2
Step 3: Choose region which is near ?  
Services -- EC2 --- Launch Instance 
Stage 1  --Name (Giving name to the machine) ubuntu
Stage 2  -- Select AMI  ( Note: Select free tier eligible ) ubuntu server
Stage 3   --  Architecture as 64-bit   
Stage 4  --  Instance type ----  t2.micro(default 1 CPU,1 GB RAM)
Stage 5  --  Create a new keypair---a keypair will downloaded  with extension .pem
                              Store key in folder AWS
Stage 6  -- Network Setting ----Create Security group  --  ( It deals with ports )
(Note for understanding We have 0 to 65535 ports. Every port is dedicated to special purpose) 
Do this step : HERE select http and https
   Stage 7 -- Storage - 8GB ( Observation - we have root - it is same as C Drive)
         Stage 8 --- click on launch instance
    Stage 9: Number of instances ---1
+++++++++++++++++++++++++++++++
Observation - One machines created
Do this step:---once it is created select that instance and click on connect
Here copy the ssh – i command from SSH client connect tab
We can use powershell /gitbash /webconsole , to connect to ubuntu machine.
NOTE:- cd path of AWS folder // change path
To connect to above terminals we need to go into the path of the keypair.and 
paste  the
 ssh -i command from the aws console

IV .Clone the application from github, Write the Dockerfile
 once connected to instance

Step 1:-  install the docker
install docker ---apt-get update

                                 apt-get install docker.io
                            apt-get install nano

step 2:-  git clone <paste the github link of maven-web-java project>
step 3:- navigate to the maven-web-java project

I.
 Create the image

Step 4:-  nano Dockerfile 



V.  Run the image and access it with public ip of virtual machine

Step 1:- build your image 
docker build –t <imagename> .(dot)
Step 2:- check for images
Step 3:- run image
docker  run –d  --name app-demo –p 6060:8080 <image name>
Step:-4 Accessing the app by public ip of virtual machine
Note:-if your are not able to connect change the inbound rules..




===============================================================================================
dockercompose.yml
# version: '3.8'  # Docker Compose file format version

# services:
#   wordpress:  # WordPress service
#     image: wordpress:latest
#     ports:
#       - "8085:80"  # Map port 80 of the container to port 8080 of the host
#     environment:
#       WORDPRESS_DB_HOST: db:3306  # Database host
#       WORDPRESS_DB_USER: wordpress
#       WORDPRESS_DB_PASSWORD: wordpress
#       WORDPRESS_DB_NAME: wordpress
#     depends_on:
#       - db  # Ensures the db service starts first

#   db:  # MySQL service
#     image: mysql:5.7
#     environment:
#       MYSQL_ROOT_PASSWORD: rootpassword
#       MYSQL_DATABASE: wordpress
#       MYSQL_USER: wordpress
#       MYSQL_PASSWORD: wordpress



#version: "3.9"
services:
  # Flask backend
  backend:
    build: ./backend
    container_name: mydockerproj-backend
    ports:
      - "5000:5000"          # Expose Flask on host:5000
    environment:
      - FLASK_ENV=development

  # Python scheduler / worker
  worker:
    build: ./worker
    container_name: mydockerproj-worker
    # No ports needed if it only runs tasks internally
    depends_on:
      - backend

  # Nginx reverse proxy
  nginx:
    image: nginx:latest
    container_name: mydockerproj-nginx
    ports:
      - "81:80"              # Expose Nginx on host:80
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - backend

